<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GLB 播放器（GLB 專用）＋骨架滑桿控制</title>
  <style>
    :root { --bg:#0b0e13; --panel:#12161f; --muted:#94a3b8; --line:#243044; --accent:#6aa1ff; }
    *{box-sizing:border-box}
    html, body { margin:0; height:100%; background:var(--bg); color:#e7e9ee; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", "Helvetica Neue", Arial;}
    #wrap { display:flex; height:100%; }
    #view { position:relative; flex: 1 1 auto; }
    #ui { width: 360px; background: var(--panel); border-left: 1px solid var(--line); padding: 14px; overflow:auto; }
    h2 { margin: 6px 0 10px; font-size: 14px; letter-spacing:.02em; }
    .block { padding-bottom: 12px; margin-bottom: 12px; border-bottom:1px dashed var(--line); }
    .row { display:flex; align-items:center; gap:8px; margin:8px 0; }
    .row label { flex: 0 0 88px; font-size: 12px; color: var(--muted); }
    input[type="file"], select, button, input[type="range"] { accent-color: var(--accent); }
    select, button { background:#0f131a; border:1px solid var(--line); color:#e7e9ee; border-radius:8px; padding:8px 10px; }
    button:hover{ border-color:#3b4a6b; cursor:pointer }
    input[type="range"] { width: 100%; }
    .small { font-size:12px; color: var(--muted); }
    #drop { position:absolute; inset:10px; border:2px dashed var(--line); border-radius:12px; display:none; align-items:center; justify-content:center; color:var(--muted); background:rgba(0,0,0,.15); pointer-events:none;}
    #toast { position: fixed; right: 12px; bottom: 12px; background:#2a1320; border:1px solid #5e2940; color:#ffd6e7; padding:10px 12px; border-radius:10px; display:none; white-space:pre-wrap; max-width:min(92vw,540px); }
    canvas { display:block; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .fill { flex: 1 1 auto; }
  </style>

  <!-- Import maps（讓 'three' 與其 addons 能被瀏覽器解析） -->
  <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="wrap">
    <div id="view">
      <div id="drop">拖放 .glb 檔到這裡</div>
    </div>
    <div id="ui">
      <div class="block">
        <h2>載入 GLB（只支援 GLB）</h2>
        <div class="row">
          <label>選擇檔案</label>
          <input id="file" type="file" accept=".glb" />
        </div>
        <div class="row">
          <button id="btnResetCam">重設相機</button>
          <button id="btnClear">清空場景</button>
        </div>
        <div class="row small"><span id="info">尚未載入</span></div>
      </div>

      <div class="block">
        <h2>動畫播放</h2>
        <div class="row">
          <label>片段</label>
          <select id="clip"></select>
        </div>
        <div class="row">
          <label>控制</label>
          <button id="btnPlay">播放/暫停</button>
          <span class="fill"></span>
          <label style="flex:0 0 auto;">速度</label>
          <input id="speed" type="range" min="0" max="2" step="0.01" value="1">
        </div>
        <div class="row">
          <label>循環</label>
          <select id="loop">
            <option value="repeat">重複</option>
            <option value="once">一次</option>
            <option value="pingpong">來回</option>
          </select>
        </div>
      </div>

      <div class="block">
        <h2>骨架控制（每幀覆寫，不改原動畫）</h2>
        <div class="row">
          <label>骨頭</label>
          <select id="bone"></select>
        </div>
        <div class="grid">
          <div class="row"><label>俯仰 Pitch</label><input id="pitch" type="range" min="-180" max="180" step="1" value="0"></div>
          <div class="row"><label>偏航 Yaw</label><input id="yaw" type="range" min="-180" max="180" step="1" value="0"></div>
          <div class="row"><label>翻滾 Roll</label><input id="roll" type="range" min="-180" max="180" step="1" value="0"></div>
          <div class="row"><label>權重</label><input id="weight" type="range" min="0" max="1" step="0.01" value="1"></div>
        </div>
        <div class="row">
          <button id="btnResetBone">重設該骨</button>
          <button id="btnResetAll">重設全部骨頭</button>
          <button id="btnResetPose">還原綁定姿勢</button>
        </div>
        <div class="row small"><span>說明：先播放 GLB 內建動畫，再把選定骨頭乘上你設定的角度（偏移）。</span></div>
      </div>
    </div>
  </div>

  <div id="toast"></div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    let scene, camera, renderer, controls, clock;
    let mixer = null, activeAction = null;
    let root = null, skinned = null, skeleton = null, actions = [];
    let bindPose = null;
    const offsets = new Map();

    const view = document.getElementById('view');
    const fileInput = document.getElementById('file');
    const btnResetCam = document.getElementById('btnResetCam');
    const btnClear = document.getElementById('btnClear');
    const info = document.getElementById('info');
    const drop = document.getElementById('drop');
    const toast = document.getElementById('toast');

    const clipSel = document.getElementById('clip');
    const btnPlay = document.getElementById('btnPlay');
    const speed = document.getElementById('speed');
    const loopSel = document.getElementById('loop');

    const boneSel = document.getElementById('bone');
    const pitch = document.getElementById('pitch');
    const yaw = document.getElementById('yaw');
    const roll = document.getElementById('roll');
    const weight = document.getElementById('weight');
    const btnResetBone = document.getElementById('btnResetBone');
    const btnResetAll = document.getElementById('btnResetAll');
    const btnResetPose = document.getElementById('btnResetPose');

    init();
    animate();

    function init(){
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b0e13);
      clock = new THREE.Clock();

      camera = new THREE.PerspectiveCamera(50, view.clientWidth / innerHeight, 0.1, 200);
      camera.position.set(0, 1.6, 4);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(devicePixelRatio);
      renderer.setSize(view.clientWidth, innerHeight);
      view.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 1.2, 0);
      controls.enableDamping = true;

      scene.add(new THREE.HemisphereLight(0xffffff, 0x223355, 0.85));
      const dir = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(3,5,2);
      scene.add(dir);
      const grid = new THREE.GridHelper(12, 24, 0x334, 0x223); grid.position.y = 0; scene.add(grid);

      addEventListener('resize', onResize);

      fileInput.addEventListener('change', e => {
        const f = e.target.files?.[0]; if (f) loadGLBFile(f);
      });
      ['dragenter','dragover'].forEach(ev => document.addEventListener(ev, e=>{ e.preventDefault(); drop.style.display='flex'; }));
      ['dragleave','drop'].forEach(ev => document.addEventListener(ev, e=>{ e.preventDefault(); drop.style.display='none'; }));
      document.addEventListener('drop', e => {
        const f = e.dataTransfer.files?.[0];
        if (f && /\.glb$/i.test(f.name)) loadGLBFile(f);
      });

      btnPlay.addEventListener('click', ()=>{ if(activeAction){ activeAction.paused = !activeAction.paused; } });
      speed.addEventListener('input', ()=>{ if(mixer) mixer.timeScale = Number(speed.value); });
      loopSel.addEventListener('change', ()=> setLoop(loopSel.value));

      btnResetCam.addEventListener('click', resetCamera);
      btnClear.addEventListener('click', clearScene);

      boneSel.addEventListener('change', syncUIFromBone);
      for(const el of [pitch,yaw,roll,weight]) el.addEventListener('input', applyUIToBone);
      btnResetBone.addEventListener('click', ()=>{ const o = offsets.get(boneSel.value); if(o){ o.ex=o.ey=o.ez=0; o.w=1; } syncUIFromBone(); });
      btnResetAll.addEventListener('click', ()=>{ offsets.forEach(o=>{ o.ex=o.ey=o.ez=0; o.w=1; }); syncUIFromBone(); });
      btnResetPose.addEventListener('click', restoreBindPose);

      info.textContent = '請載入 .glb（需包含骨架；可有動畫）';
    }

    function onResize(){
      camera.aspect = view.clientWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(view.clientWidth, innerHeight);
    }

    function resetCamera(){
      controls.target.set(0,1.2,0);
      camera.position.set(0,1.6,4);
      controls.update();
    }

    function clearScene(){
      if(root){
        root.traverse(o => {
          if (o.geometry) o.geometry.dispose();
          if (o.material){
            if (Array.isArray(o.material)) o.material.forEach(m=>m.dispose());
            else o.material.dispose();
          }
        });
        scene.remove(root);
        root=null; skinned=null; skeleton=null;
      }
      if(mixer){ mixer.stopAllAction(); mixer = null; }
      activeAction = null; actions = [];
      clipSel.innerHTML = '';
      boneSel.innerHTML = ''; offsets.clear();
      bindPose = null;
      info.textContent = '已清空場景';
    }

    async function loadGLBFile(file){
      try{
        clearScene();
        info.textContent = '載入中… ' + file.name;
        const url = URL.createObjectURL(file);
        const loader = new GLTFLoader();
        loader.load(url, (gltf)=>{
          URL.revokeObjectURL(url);
          useGLTF(gltf.scene, gltf.animations || []);
          info.textContent = '✅ 已載入：' + file.name;
        }, undefined, (err)=>{
          showToast('載入失敗：' + (err?.message||err));
          info.textContent = '❌ 失敗';
        });
      }catch(e){
        showToast('載入時出錯：' + (e?.message||e));
      }
    }

    function useGLTF(sceneObj, clips){
      root = sceneObj;
      scene.add(root);
      root.traverse(o=>{ if(o.isSkinnedMesh && !skinned) skinned = o; });
      if (!skinned) { showToast('⚠️ 未找到 SkinnedMesh（此 GLB 可能沒有骨架/權重）'); }
      else {
        skeleton = skinned.skeleton;
        buildBoneList(skeleton);
        captureBindPose();
      }

      actions = [];
      if (clips && clips.length){
        mixer = new THREE.AnimationMixer(root);
        clips.forEach((clip,i)=>{
          const act = mixer.clipAction(clip, root);
          actions.push({ name: clip.name || ('片段'+i), action: act });
        });
        clipSel.innerHTML='';
        actions.forEach((a,i)=>{
          const opt = document.createElement('option'); opt.value=i; opt.textContent=a.name; clipSelect.appendChild(opt);
        });
        clipSel.onchange = ()=> chooseClip(Number(clipSel.value));
        chooseClip(0);
        setLoop(loopSel.value);
        mixer.timeScale = Number(speed.value);
      }else{
        clipSel.innerHTML='';
        const opt = document.createElement('option'); opt.textContent='（未偵測到動畫）'; opt.disabled=true; opt.selected=true;
        clipSel.appendChild(opt);
      }
      resetCamera();
    }

    function chooseClip(idx){
      if (!mixer || !actions.length) return;
      if (activeAction) activeAction.stop();
      activeAction = actions[idx].action;
      activeAction.reset().play();
    }

    function setLoop(mode){
      if (!activeAction) return;
      if (mode==='once'){ activeAction.setLoop(THREE.LoopOnce,0); activeAction.clampWhenFinished=true; }
      else if (mode==='pingpong'){ activeAction.setLoop(THREE.LoopPingPong,Infinity); activeAction.clampWhenFinished=false; }
      else { activeAction.setLoop(THREE.LoopRepeat,Infinity); activeAction.clampWhenFinished=false; }
    }

    function captureBindPose(){
      if(!skeleton) return;
      bindPose = skeleton.bones.map(b=>({ b, p:b.position.clone(), q:b.quaternion.clone(), s:b.scale.clone() }));
    }
    function restoreBindPose(){
      if(!bindPose) return;
      for(const t of bindPose){
        t.b.position.copy(t.p);
        t.b.quaternion.copy(t.q);
        t.b.scale.copy(t.s);
        t.b.updateMatrix(); t.b.updateMatrixWorld(true);
      }
    }

    function norm(n){ return n.toLowerCase().replace(/^armature\|/,'').replace(/^mixamorig:/,'').replace(/[^a-z]/g,''); }
    function headToToeOrder(name){
      const n = norm(name);
      const order = [
        ['head', 0], ['neck', 10],
        ['chest', 20], ['spine2', 21], ['spine1', 22], ['spine', 23],
        ['hips', 30], ['pelvis', 31],
        ['leftshoulder', 40], ['rightshoulder', 41],
        ['leftupperarm', 50], ['rightupperarm', 51], ['leftarm', 52], ['rightarm', 53],
        ['leftforearm', 60], ['rightforearm', 61],
        ['lefthand', 70], ['righthand', 71],
        ['leftupleg', 80], ['rightupleg', 81], ['leftthigh',82], ['rightthigh',83],
        ['leftleg', 90], ['rightleg', 91], ['leftcalf',92], ['rightcalf',93],
        ['leftfoot', 100], ['rightfoot', 101],
        ['lefttoebase', 110], ['righttoebase', 111], ['lefttoe',112], ['righttoe',113]
      ];
      for (const [k, r] of order){ if (n.includes(k)) return r; }
      return 500;
    }
    function buildBoneList(skel){
      boneSel.innerHTML='';
      offsets.clear();
      const names = skel.bones.map(b=>b.name).sort((a,b)=> headToToeOrder(a)-headToToeOrder(b) || a.localeCompare(b));
      for(const n of names){
        const opt = document.createElement('option'); opt.value=n; opt.textContent=n; boneSel.appendChild(opt);
        offsets.set(n, {ex:0, ey:0, ez:0, w:1});
      }
      boneSel.value = names[0] || '';
      syncUIFromBone();
    }
    function syncUIFromBone(){
      const o = offsets.get(boneSel.value);
      if(!o) return;
      pitch.value = o.ex; yaw.value = o.ey; roll.value = o.ez; weight.value = o.w;
    }
    function applyUIToBone(){
      const o = offsets.get(boneSel.value);
      if(!o) return;
      o.ex = Number(pitch.value); o.ey = Number(yaw.value); o.ez = Number(roll.value); o.w = Number(weight.value);
    }

    const tmpQ = new THREE.Quaternion();
    const offQ = new THREE.Quaternion();
    const eul  = new THREE.Euler();
    const d2r  = THREE.MathUtils.degToRad;

    function animate(){
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      if (mixer) mixer.update(dt);
      if (skeleton && offsets.size){
        for (const [name, o] of offsets){
          if (o.w <= 0) continue;
          const bone = skeleton.bones.find(b => b.name === name);
          if (!bone) continue;
          tmpQ.copy(bone.quaternion);
          eul.set(d2r(o.ex), d2r(o.ey), d2r(o.ez), 'XYZ');
          offQ.setFromEuler(eul);
          tmpQ.multiply(offQ);
          bone.quaternion.slerp(tmpQ, o.w);
        }
      }
      controls.update();
      renderer.render(scene, camera);
    }

    function showToast(msg){
      toast.textContent = '⚠️ ' + msg;
      toast.style.display = 'block';
      setTimeout(()=> toast.style.display='none', 4000);
    }
  </script>
</body>
</html>
