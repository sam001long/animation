<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Mocap Demoï½œBVH/GLB â†’ è§’è‰²é‡å®šå‘ï¼ˆé›™ Mixerï¼‹CMU å°ç…§ï¼‰</title>
<style>
  :root { --bg:#0f1115; --panel:#161922; --text:#e8e8ea; --muted:#9aa0a6; --acc:#4f8cff; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,-apple-system,Segoe UI,Roboto}
  #app{position:fixed;inset:0}
  #togglePanel{
    position:fixed;left:12px;top:12px;z-index:20;width:44px;height:44px;border-radius:12px;
    border:1px solid #283044;background:#111523;color:var(--text);font-size:22px;line-height:44px;text-align:center
  }
  #togglePanel:hover{border-color:#3b4a6b;cursor:pointer}
  #ui{
    position:fixed;left:12px;top:64px;display:flex;gap:10px;align-items:center;flex-wrap:wrap;
    padding:10px 12px;background:rgba(22,25,34,.92);backdrop-filter:blur(8px);
    border-radius:14px;box-shadow:0 6px 24px rgba(0,0,0,.35);max-width:min(96vw,1200px);z-index:10
  }
  #ui .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  #ui label{font-size:12px;color:var(--muted)}
  #ui input[type="file"], select, button, input[type="range"], input[type="checkbox"]{accent-color:var(--acc)}
  select,button{background:#111523;border:1px solid #283044;color:var(--text);border-radius:10px;padding:8px 10px;font-size:14px}
  button:hover{border-color:#3b4a6b;cursor:pointer}
  #status{font-size:12px;color:var(--muted)}
  #drop{position:fixed;inset:0;pointer-events:none;border:2px dashed transparent;border-radius:18px}
  #drop.active{pointer-events:none;border-color:#3b82f6;box-shadow:0 0 0 999vmax rgba(59,130,246,.08) inset}
  #errorToast{
    position:fixed;right:12px;bottom:12px;max-width:min(96vw,560px);
    padding:10px 12px;background:#301b1b;color:#ffd7d7;border:1px solid #5f2c2c;border-radius:12px;display:none;white-space:pre-wrap;line-height:1.4
  }
  .badge{padding:2px 8px;border-radius:999px;background:#23283a;color:#b8c1ff;font-size:12px}
  @media (max-width:640px){ #ui{max-height:60vh;overflow:auto} }
</style>
</head>
<body>
<div id="app"></div>

<button id="togglePanel">â˜°</button>

<div id="ui">
  <div class="row">
    <span class="badge">Step 1</span>
    <button id="btnLoadModel">è¼‰å…¥é è¨­è§’è‰²ï¼ˆ./character.glbï¼‰</button>
    <label>æˆ–ä¸Šå‚³è§’è‰² <input id="charInput" type="file" accept=".glb,.gltf"/></label>
    <button id="btnLoadSoldier">ä¸€éµç”¨ Soldier</button>
    <span id="status">åˆå§‹åŒ–ä¸­â€¦</span>
  </div>
  <div class="row" style="width:100%">
    <span class="badge">Step 2</span>
    <label>ä¸Šå‚³å‹•ä½œï¼ˆ.bvh æˆ– .glbï¼‰
      <input id="motionInput" type="file" accept=".bvh,.glb,.gltf" multiple/>
    </label>
    <button id="btnLoadSamples">ä¸€éµè¼‰å…¥ç¤ºç¯„å‹•ä½œï¼ˆWalk/Run/Jumpï¼‰</button>
  </div>
  <div class="row" style="width:100%">
    <label>å‹•ä½œæ¸…å–®
      <select id="motionSelect" style="min-width:260px">
        <option disabled selected>ï¼ˆå°šæœªè¼‰å…¥å‹•ä½œï¼‰</option>
      </select>
    </label>
    <button id="playBtn">æ’­æ”¾</button>
    <button id="pauseBtn">æš«åœ</button>
    <label>å¾ªç’° <input id="loopChk" type="checkbox" checked/></label>
    <label style="display:flex;align-items:center;gap:6px">é€Ÿåº¦
      <input id="speed" type="range" min="0.1" max="2.0" step="0.05" value="1"/>
    </label>
  </div>
</div>

<div id="drop"></div>
<div id="errorToast"></div>

<script type="module">
import * as THREE from 'https://esm.sh/three@0.152.2';
import { OrbitControls } from 'https://esm.sh/three@0.152.2/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from 'https://esm.sh/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';
import { BVHLoader } from 'https://esm.sh/three@0.152.2/examples/jsm/loaders/BVHLoader.js';
import * as SkeletonUtils from 'https://esm.sh/three@0.152.2/examples/jsm/utils/SkeletonUtils.js';

/* Soldier å€™é¸æºï¼šé¿å… 403/404 */
const SOLDIER_CANDIDATES = [
  "https://raw.githubusercontent.com/mrdoob/three.js/r152/examples/models/gltf/Soldier.glb",
  "https://rawcdn.githack.com/mrdoob/three.js/r152/examples/models/gltf/Soldier.glb"
];

/* DOM */
const app = document.getElementById("app");
const statusEl = document.getElementById("status");
const btnLoadModel = document.getElementById("btnLoadModel");
const btnLoadSoldier = document.getElementById("btnLoadSoldier");
const charInput = document.getElementById("charInput");
const motionInput = document.getElementById("motionInput");
const motionSelect = document.getElementById("motionSelect");
const playBtn = document.getElementById("playBtn");
const pauseBtn = document.getElementById("pauseBtn");
const loopChk = document.getElementById("loopChk");
const speed = document.getElementById("speed");
const drop = document.getElementById("drop");
const errorToast = document.getElementById("errorToast");
const togglePanelBtn = document.getElementById("togglePanel");

/* State */
let renderer, scene, camera, controls, clock = new THREE.Clock();
let model, targetSkeleton, targetMesh;
let mixerBones, mixerNodes;               // é›™ Mixer
const actions = new Map();                // name -> { action, mixer:'bones'|'nodes' }
let current = null;
let panelOpen = false;

/* åˆå§‹åŒ– */
init().catch(showFatal);

async function init(){
  panelOpen = matchMedia('(min-width: 641px)').matches;
  setPanel(panelOpen);
  togglePanelBtn.addEventListener('click', ()=> setPanel(!panelOpen));
  window.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='h') setPanel(!panelOpen); });

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(Math.min(devicePixelRatio,2));
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  app.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0f1115);

  camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, .1, 100);
  camera.position.set(0,1.6,3);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.target.set(0,1,0);
  controls.update();

  const hemi = new THREE.HemisphereLight(0xffffff, 0x202035, .9);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 1.2);
  dir.position.set(3,5,2);
  dir.castShadow = true;
  dir.shadow.mapSize.set(2048,2048);
  scene.add(dir);

  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(30,30),
    new THREE.MeshStandardMaterial({color:0x171a24, roughness:1})
  );
  floor.rotation.x = -Math.PI/2;
  floor.receiveShadow = true;
  scene.add(floor);

  window.addEventListener("resize", onResize);

  btnLoadModel.addEventListener("click", ()=>loadCharacterLocal("./character.glb"));
  btnLoadSoldier.addEventListener("click", ()=>loadCharacterFromCandidates(SOLDIER_CANDIDATES, "Soldier"));

  charInput.addEventListener("change", e=>{
    const f = e.target.files?.[0]; if(!f) return;
    loadCharacterFromFile(f);
  });

  motionInput.addEventListener("change", e=>{
    if(!ensureModel()) return;
    const files = [...(e.target.files||[])];
    loadMultipleMotions(files);
    autoCloseOnMobile();
  });

  document.getElementById("btnLoadSamples").addEventListener("click", async ()=>{
    if(!ensureModel()) return;
    setStatus("è¼‰å…¥ç¤ºç¯„å‹•ä½œä¸­â€¦");
    const CANDIDATES = {
      "Walk": ["./motions/walk.bvh","https://raw.githubusercontent.com/una-dinosauria/cmu-mocap/master/data/007/07_01.bvh"],
      "Run (09_01)": ["./motions/run.bvh","https://raw.githubusercontent.com/una-dinosauria/cmu-mocap/master/data/009/09_01.bvh"],
      "Jump": ["./motions/jump.bvh"]
    };
    for (const [name, urls] of Object.entries(CANDIDATES)) {
      let ok=false,lastErr=null;
      for(const url of urls){ try{ await loadBVHFromURL(url, name); ok=true; break; } catch(e){ lastErr=e; } }
      if(!ok) showError(`ç¤ºç¯„å‹•ä½œè¼‰å…¥å¤±æ•—ï¼ˆ${name}ï¼‰ï¼š`+(lastErr?.message||æœ€å¾ŒErr));
    }
    setStatus(`å·²è¼‰å…¥ ${actions.size} æ”¯å‹•ä½œ`);
    if(actions.size && !current){ const first = actions.keys().next().value; motionSelect.value = first; switchToAction(first, 0.0); }
    autoCloseOnMobile();
  });

  motionSelect.addEventListener("change", ()=>{
    const name = motionSelect.value;
    switchToAction(name, 0.35);
    autoCloseOnMobile();
  });
  playBtn.addEventListener("click", ()=>{ current?.action?.play(); if(current) current.action.paused=false; setStatus("æ’­æ”¾"); autoCloseOnMobile(); });
  pauseBtn.addEventListener("click", ()=>{ if(current){ current.action.paused = true; setStatus("æš«åœ"); }});
  speed.addEventListener("input", ()=>{ const v=Number(speed.value); if(mixerBones) mixerBones.timeScale=v; if(mixerNodes) mixerNodes.timeScale=v; });
  loopChk.addEventListener("change", ()=>{
    for(const {action} of actions.values()){
      action.setLoop(loopChk.checked ? THREE.LoopRepeat : THREE.LoopOnce, Infinity);
      action.clampWhenFinished = !loopChk.checked;
    }
  });

  window.addEventListener("dragover", e=>{ e.preventDefault(); drop.classList.add("active"); });
  window.addEventListener("dragleave", ()=>{ drop.classList.remove("active"); });
  window.addEventListener("drop", e=>{
    e.preventDefault(); drop.classList.remove("active");
    if(!ensureModel()) return;
    const files = [...(e.dataTransfer?.files||[])];
    if(files.length) loadMultipleMotions(files);
    autoCloseOnMobile();
  });

  document.addEventListener('pointerdown', (ev)=>{ if (ev.target === renderer.domElement) autoCloseOnMobile(); });

  setStatus("è«‹å…ˆè¼‰å…¥è§’è‰²ï¼ˆæŒ‰éˆ•æˆ–ä¸Šå‚³ GLBï¼‰");
  animate();
}

/* é¢æ¿ */
function setPanel(open){ panelOpen=open; document.getElementById('ui').style.display=open?'flex':'none'; togglePanelBtn.textContent=open?'Ã—':'â˜°'; }
function autoCloseOnMobile(){ if (matchMedia('(max-width: 640px)').matches && panelOpen) setPanel(false); }

/* è¦–çª— */
function onResize(){ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); }

/* è‹¥æ‰¾ä¸åˆ° ./character.glbï¼Œè‡ªå‹• fallback åˆ° Soldier */
async function loadCharacterLocal(url){
  try{
    setStatus(`è¼‰å…¥è§’è‰²ä¸­â€¦ï¼ˆæœ¬åœ°ï¼‰`);
    const head = await fetch(url,{method:"HEAD"});
    if(!head.ok) throw new Error(`æ‰¾ä¸åˆ° ${url}ï¼ˆHTTP ${head.status}ï¼‰`);
    const gltf = await new GLTFLoader().loadAsync(url);
    useLoadedCharacter(gltf.scene, gltf.animations||[]);
    setStatus("é è¨­è§’è‰²è¼‰å…¥æˆåŠŸ");
  }catch(err){
    showError("æ‰¾ä¸åˆ° ./character.glbï¼Œæ”¹ç‚ºè¼‰å…¥ Soldierã€‚ä¹‹å¾Œå¯æŠŠä½ çš„æ¨¡å‹æ”¾åœ¨ repo æ ¹ç›®éŒ„ä¸¦å‘½åç‚º character.glbã€‚");
    await loadCharacterFromCandidates(SOLDIER_CANDIDATES, "Soldierï¼ˆfallbackï¼‰");
  }
}
async function loadCharacterFromCandidates(candidates,label){
  let lastErr=null;
  for(const url of candidates){
    try{
      setStatus(`è¼‰å…¥è§’è‰²ä¸­â€¦ï¼ˆ${label}ï¼‰`);
      const gltf = await new GLTFLoader().loadAsync(url);
      useLoadedCharacter(gltf.scene, gltf.animations||[]);
      setStatus(`è¼‰å…¥ ${label} æˆåŠŸ`); return;
    }catch(e){ lastErr=e; }
  }
  showError(`è¼‰å…¥ ${label} å¤±æ•—ï¼š`+(lastErr?.message||lastErr));
}
async function loadCharacterFromFile(file){
  try{
    setStatus("è§£æè§’è‰²æª”â€¦");
    const url = URL.createObjectURL(file);
    const gltf = await new GLTFLoader().loadAsync(url);
    URL.revokeObjectURL(url);
    useLoadedCharacter(gltf.scene, gltf.animations||[]);
    setStatus("ä¸Šå‚³è§’è‰²è¼‰å…¥æˆåŠŸ");
  }catch(err){ showError("ä¸Šå‚³è§’è‰²å¤±æ•—ï¼š"+(err?.message||err)); }
}

function useLoadedCharacter(sceneObj, characterClips=[]){
  if(model){
    scene.remove(model);
    for(const {action} of actions.values()) action.stop();
    actions.clear(); updateMotionSelect(); current=null; targetSkeleton=null; targetMesh=null;
  }
  model = sceneObj;

  // æ‰¾ä¸» SkinnedMeshï¼ˆéª¨é ­æœ€å¤šï¼‰
  targetMesh = null; targetSkeleton = null;
  model.traverse(o=>{
    if (o.isSkinnedMesh && o.skeleton){
      const cur = (targetSkeleton && targetSkeleton.bones.length) || 0;
      if (!targetMesh || o.skeleton.bones.length > cur){
        targetMesh = o; targetSkeleton = o.skeleton;
      }
    }
  });
  if(!targetSkeleton){ throw new Error("æ‰¾ä¸åˆ° SkinnedMesh/Skeletonï¼Œè«‹ç¢ºèªè§’è‰²å·²ç¶éª¨ã€‚"); }
  model.position.set(0,0,0); scene.add(model);

  // å…©å€‹ mixerï¼šbones èˆ‡ nodes
  mixerBones = new THREE.AnimationMixer(targetMesh);
  mixerNodes = new THREE.AnimationMixer(model);
  const v = Number(speed.value); mixerBones.timeScale=v; mixerNodes.timeScale=v;

  // è§’è‰²è‡ªå¸¶å‹•ç•«ï¼šæŒ‰è»Œé“å‹æ…‹åˆ†é… mixerï¼ˆä¸åšè‡ªæˆ‘ retargetï¼‰
  if(Array.isArray(characterClips) && characterClips.length){
    characterClips.forEach((clip, idx)=>{
      const name = `GLB / ${clip.name || ("Clip"+idx)}`;
      const isBones = clip.tracks.some(t=>t.name.startsWith("bones["));
      addAction(clip, name, isBones ? 'bones' : 'nodes');
    });
    updateMotionSelect();
    const first = actions.keys().next().value;
    if(first){ motionSelect.value = first; switchToAction(first, 0.0); }
    setStatus(`è§’è‰² OKï¼šå·²è¼‰å…¥ ${characterClips.length} å€‹å…§å»ºå‹•ä½œï¼›ä¹Ÿå¯å†ä¸Šå‚³ BVH/GLB`);
  }else{
    setStatus("è§’è‰² OKï¼šå¯ä¸Šå‚³ .bvh æˆ– .glbï¼ˆå‹•ä½œä¾†æºï¼‰ï¼Œæˆ–é»ã€ä¸€éµè¼‰å…¥ç¤ºç¯„å‹•ä½œã€");
  }
}
function ensureModel(){ if(!model){ showError("è«‹å…ˆè¼‰å…¥è§’è‰²ï¼ˆæŒ‰éˆ•æˆ–ä¸Šå‚³ GLBï¼‰ã€‚"); return false; } return true; }

/* ä¾ã€Œç›®æ¨™éª¨æ¶ã€ç”¢ç”Ÿ CMUâ†’ç›®æ¨™ çš„éª¨åå°ç…§è¡¨ */
function buildCMUNameMapForTarget(targetSkel){
  const tnames = targetSkel.bones.map(b=>b.name);
  const isMixamo = tnames.some(n => n.startsWith('mixamorig:')); // Soldier / Mixamo

  if (isMixamo){
    return {
      "mixamorig:Hips":"Hips","mixamorig:Spine":"LowerBack","mixamorig:Spine1":"Spine","mixamorig:Spine2":"Spine1",
      "mixamorig:Neck":"Neck","mixamorig:Head":"Head",
      "mixamorig:LeftShoulder":"LeftCollar","mixamorig:LeftArm":"LeftShoulder","mixamorig:LeftForeArm":"LeftElbow","mixamorig:LeftHand":"LeftWrist",
      "mixamorig:RightShoulder":"RightCollar","mixamorig:RightArm":"RightShoulder","mixamorig:RightForeArm":"RightElbow","mixamorig:RightHand":"RightWrist",
      "mixamorig:LeftUpLeg":"LeftUpLeg","mixamorig:LeftLeg":"LeftLeg","mixamorig:LeftFoot":"LeftFoot","mixamorig:LeftToeBase":"LeftToe",
      "mixamorig:RightUpLeg":"RightUpLeg","mixamorig:RightLeg":"RightLeg","mixamorig:RightFoot":"RightFoot","mixamorig:RightToeBase":"RightToe"
    };
  }
  return { // ç›®æ¨™ä¸€èˆ¬ glTF å‘½åï¼ˆHips/Spineâ€¦ï¼‰
    "Hips":"Hips","Spine":"LowerBack","Spine1":"Spine","Spine2":"Spine1","Neck":"Neck","Head":"Head",
    "LeftShoulder":"LeftCollar","LeftArm":"LeftShoulder","LeftForeArm":"LeftElbow","LeftHand":"LeftWrist",
    "RightShoulder":"RightCollar","RightArm":"RightShoulder","RightForeArm":"RightElbow","RightHand":"RightWrist",
    "LeftUpLeg":"LeftUpLeg","LeftLeg":"LeftLeg","LeftFoot":"LeftFoot","LeftToeBase":"LeftToe",
    "RightUpLeg":"RightUpLeg","RightLeg":"RightLeg","RightFoot":"RightFoot","RightToeBase":"RightToe"
  };
}

/* è¼‰å…¥å¤šå€‹å‹•ä½œ */
async function loadMultipleMotions(files){
  const bvhFiles = files.filter(f => /\.bvh($|\.)/i.test(f.name));
  const glbFiles = files.filter(f => /\.(glb|gltf)$/i.test(f.name));
  if(bvhFiles.length){ setStatus(`è¼‰å…¥ ${bvhFiles.length} æ”¯ BVHâ€¦`); for(const f of bvhFiles){ await loadBVHFromFile(f).catch(err=>showError(err.message)); } }
  if(glbFiles.length){ setStatus(`è¼‰å…¥ ${glbFiles.length} å€‹ GLB å‹•ä½œä¾†æºâ€¦`); for(const f of glbFiles){ await loadMotionGLB(f).catch(err=>showError(err.message)); } }
  setStatus(`å·²è¼‰å…¥ ${actions.size} æ”¯å‹•ä½œ`);
  if(actions.size && !current){ const first = actions.keys().next().value; motionSelect.value = first; switchToAction(first, 0.0); }
}
async function loadBVHFromFile(file){ const url = URL.createObjectURL(file); try{ const res = await new BVHLoader().loadAsync(url); addRetargetedClip(res, file.name.replace(/\.(bvh(\.txt)?)$/i,"")); } finally{ URL.revokeObjectURL(url); } }
async function loadBVHFromURL(url, displayName){ const res = await new BVHLoader().loadAsync(url); addRetargetedClip(res, displayName || url.split("/").pop().replace(/\.(bvh(\.txt)?)$/i,"")); }

/* BVH â†’ è§’è‰²ï¼ˆè¼¸å‡º bones[...]ï¼Œç”¨ bones mixerï¼‰ */
function addRetargetedClip(bvhResult, name){
  if (!targetSkeleton || !targetMesh) { showError("è«‹å…ˆè¼‰å…¥è§’è‰²å†è¼‰å…¥å‹•ä½œ"); return; }
  if (!bvhResult || typeof bvhResult !== 'object') { showError(`BVH è§£æçµæœç•°å¸¸ï¼š${bvhResult}`); return; }

  // ä¾†æºéª¨æ¶
  let bonesArray=null; const r=bvhResult;
  if (r.skeleton?.bones?.length) bonesArray=r.skeleton.bones;
  else if (r.skeletonHelper?.skeleton?.bones?.length) bonesArray=r.skeletonHelper.skeleton.bones;
  else if (r.skeletonHelper?.bones?.length) bonesArray=r.skeletonHelper.bones;
  else if (Array.isArray(r.bones) && r.bones.length) bonesArray=r.bones;
  else if (r.restPose?.bones?.length) bonesArray=r.restPose.bones;
  if(!bonesArray){ showError(`é€™æ”¯ BVH æœªè§£æåˆ°éª¨æ¶ï¼Œå·²è·³éï¼š${name}`); return; }
  const sourceSkeleton = (r.skeleton && r.skeleton.bones === bonesArray) ? r.skeleton : new THREE.Skeleton(bonesArray);

  // clip
  let clip = (r.clip && typeof r.clip.clone === 'function') ? r.clip.clone() : r.clip;
  if (!clip) { showError(`BVH ç„¡å‹•ç•« clipï¼Œå·²è·³éï¼š${name}`); return; }

  // åªç•™ Hips çš„ Y å¹³ç§»
  const srcHipName = "Hips";
  clip.tracks = clip.tracks.filter(t => !t.name.endsWith(".position") || t.name === (srcHipName + ".position"));
  const hipPos = clip.tracks.find(t => t.name === (srcHipName + ".position"));
  if (hipPos) { const a = hipPos.values; for (let i=0;i<a.length;i+=3){ a[i]=0; a[i+2]=0; } }

  // åˆ¤åˆ¥æ˜¯å¦ CMUï¼Œå»ºç«‹å°ç…§è¡¨
  const srcNames = (sourceSkeleton.bones||[]).map(b=>b.name);
  const looksLikeCMU = srcNames.includes("LeftCollar") || srcNames.includes("RightCollar");
  const namesMap = looksLikeCMU ? buildCMUNameMapForTarget(targetSkeleton) : undefined;

  const hipGuess = guessHipName(targetSkeleton);

  try{
    const retargeted = SkeletonUtils.retargetClip(
      targetMesh, sourceSkeleton, clip,
      { hip: hipGuess, useTargetMatrix:true, preserveHipPosition:true, names: namesMap }
    );
    addAction(retargeted, name, 'bones');
  }catch(e){ showError(`é‡å®šå‘å¤±æ•—ï¼ˆ${name}ï¼‰ï¼š` + (e?.message||e)); }
}

/* GLB å‹•ä½œä¾†æº â†’ ç›®å‰è§’è‰²ï¼ˆè¼¸å‡º bones[...]ï¼Œç”¨ bones mixerï¼‰ */
async function loadMotionGLB(file){
  const url = URL.createObjectURL(file);
  try{
    const gltf = await new GLTFLoader().loadAsync(url);
    let sourceSkeleton=null; gltf.scene.traverse(o=>{ if(o.isSkinnedMesh && !sourceSkeleton){ sourceSkeleton=o.skeleton; }});
    if(!sourceSkeleton || !gltf.animations?.length){ throw new Error(`GLB ç„¡å¯ç”¨éª¨æ¶/å‹•ç•«ï¼š${file.name}`); }
    const hipGuess = guessHipName(targetSkeleton);
    gltf.animations.forEach((clip, idx)=>{
      const clean = clip.clone();
      clean.tracks = clean.tracks.filter(t=>!t.name.endsWith(".position"));
      const retargeted = SkeletonUtils.retargetClip(
        targetMesh, sourceSkeleton, clean,
        { preserveHipPosition:true, useTargetMatrix:true, hip: hipGuess }
      );
      const name = `${file.name.replace(/\.(gltf|glb)$/i,"")} / ${clip.name||("Clip"+idx)}`;
      addAction(retargeted, name, 'bones');
    });
  }finally{ URL.revokeObjectURL(url); }
}

/* çŒœ Hips åç¨± */
function guessHipName(skel){
  const names = skel.bones.map(b=>b.name);
  const list = ["Hips","mixamorig:Hips","hip","hips","Root","root"];
  for(const n of list){ if(names.includes(n)) return n; }
  const hit = names.find(n=>/hip/i.test(n));
  return hit || "Hips";
}

/* å‹•ä½œç®¡ç†ï¼ˆé›™ Mixerï¼‰ */
function addAction(clip, name, mixerKind){
  const mixer = mixerKind==='nodes' ? mixerNodes : mixerBones;
  const action = mixer.clipAction(clip);
  action.enabled = true;
  action.setLoop(loopChk.checked?THREE.LoopRepeat:THREE.LoopOnce, Infinity);
  action.clampWhenFinished = !loopChk.checked;
  action.time = 0; action.paused = false;
  actions.set(name, {action, mixer:mixerKind}); updateMotionSelect();
}
function updateMotionSelect(){
  motionSelect.innerHTML = "";
  if(!actions.size){
    const opt = document.createElement("option"); opt.disabled=true; opt.selected=true; opt.textContent="ï¼ˆå°šæœªè¼‰å…¥å‹•ä½œï¼‰";
    motionSelect.appendChild(opt); return;
  }
  for(const name of actions.keys()){
    const opt = document.createElement("option"); opt.value=name; opt.textContent=name; motionSelect.appendChild(opt);
  }
}
function switchToAction(name, fade=0.35){
  const next = actions.get(name); if(!next){ showError("æ‰¾ä¸åˆ°å‹•ä½œï¼š"+name); return; }
  if(current && current.mixer!==next.mixer){
    current.action.stop();
    next.action.reset().play();
  }else if(current){
    current.action.crossFadeTo(next.action.reset().play(), fade, true);
  }else{
    next.action.reset().play();
  }
  current = next; setStatus(`æ’­æ”¾ï¼š${name}`);
}

/* å…¶ä»– */
function setStatus(msg){ statusEl.textContent = msg; }
function animate(){ requestAnimationFrame(animate); const dt = clock.getDelta(); mixerBones?.update(dt); mixerNodes?.update(dt); renderer.render(scene, camera); }
function showError(msg){ console.error(msg); statusEl.textContent="âš ï¸ "+msg; errorToast.textContent="âš ï¸ "+msg; errorToast.style.display="block"; }
function showFatal(err){ console.error(err); errorToast.textContent="ğŸš« åˆå§‹åŒ–å¤±æ•—ï¼š\n"+(err?.message||err); errorToast.style.display="block"; statusEl.textContent="ğŸš« åˆå§‹åŒ–å¤±æ•—"; }
window.addEventListener("error",(e)=>showError("è…³æœ¬éŒ¯èª¤ï¼š"+(e?.message||"unknown")));
window.addEventListener("unhandledrejection",(e)=>showError("Promise éŒ¯èª¤ï¼š"+(e?.reason?.message||e?.reason||"unknown")));
</script>

<noscript>éœ€è¦å•Ÿç”¨ JavaScript æ‰èƒ½é‹è¡Œæ­¤ Demoã€‚</noscript>
</body>
</html>
