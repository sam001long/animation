<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Mocap Demoï½œç©©å®šç‰ˆ v3f</title>
<style>
  :root { --bg:#0f1115; --panel:#161922; --text:#e8e8ea; --muted:#9aa0a6; --acc:#4f8cff; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,-apple-system,Segoe UI,Roboto}
  #app{position:fixed;inset:0}
  #togglePanel{position:fixed;left:12px;top:12px;z-index:20;width:44px;height:44px;border-radius:12px;border:1px solid #283044;background:#111523;color:var(--text);font-size:22px;line-height:44px;text-align:center}
  #togglePanel:hover{border-color:#3b4a6b;cursor:pointer}
  #ui{position:fixed;left:12px;top:64px;display:flex;gap:10px;align-items:center;flex-wrap:wrap;padding:10px 12px;background:rgba(22,25,34,.92);backdrop-filter:blur(8px);border-radius:14px;box-shadow:0 6px 24px rgba(0,0,0,.35);max-width:min(96vw,1200px);z-index:10}
  #ui .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  #ui label{font-size:12px;color:var(--muted)}
  #ui input[type="file"], select, button, input[type="range"], input[type="checkbox"]{accent-color:var(--acc)}
  select,button{background:#111523;border:1px solid #283044;color:var(--text);border-radius:10px;padding:8px 10px;font-size:14px}
  button:hover{border-color:#3b4a6b;cursor:pointer}
  #status{font-size:12px;color:var(--muted)}
  #errorToast{position:fixed;right:12px;bottom:12px;max-width:min(96vw,560px);padding:10px 12px;background:#301b1b;color:#ffd7d7;border:1px solid #5f2c2c;border-radius:12px;display:none;white-space:pre-wrap;line-height:1.4}
  .badge{padding:2px 8px;border-radius:999px;background:#23283a;color:#b8c1ff;font-size:12px}
  #debug{font-size:12px;color:#b8c1ff;margin-left:8px}
  @media (max-width:640px){ #ui{max-height:60vh;overflow:auto} }
</style>
</head>
<body>
<div id="app"></div>

<button id="togglePanel">â˜°</button>

<div id="ui">
  <div class="row">
    <span class="badge">Step 1</span>
    <button id="btnLoadModel">è¼‰å…¥é è¨­è§’è‰²ï¼ˆ./character.glbï¼‰</button>
    <label>æˆ–ä¸Šå‚³è§’è‰² <input id="charInput" type="file" accept=".glb,.gltf"/></label>
    <button id="btnLoadSoldier">ä¸€éµç”¨ Soldier</button>
    <span id="status">åˆå§‹åŒ–ä¸­â€¦</span>
    <span id="debug"></span>
  </div>
  <div class="row" style="width:100%">
    <span class="badge">Step 2</span>
    <label>ä¸Šå‚³å‹•ä½œï¼ˆ.bvh æˆ– .glbï¼‰
      <input id="motionInput" type="file" accept=".bvh,.glb,.gltf" multiple/>
    </label>
    <button id="btnLoadSamples">ä¸€éµè¼‰å…¥ç¤ºç¯„ BVHï¼ˆå…ˆæ‰¾æœ¬æ©Ÿ ./motionsï¼Œå†æ‰¾ç·šä¸Šï¼‰</button>
  </div>
  <div class="row" style="width:100%">
    <label>å‹•ä½œæ¸…å–®
      <select id="motionSelect" style="min-width:260px">
        <option disabled selected>ï¼ˆå°šæœªè¼‰å…¥å‹•ä½œï¼‰</option>
      </select>
    </label>
    <button id="playBtn">æ’­æ”¾</button>
    <button id="pauseBtn">æš«åœ</button>
    <label>å¾ªç’° <input id="loopChk" type="checkbox" checked/></label>
    <label style="display:flex;align-items:center;gap:6px">é€Ÿåº¦
      <input id="speed" type="range" min="0.1" max="2.0" step="0.05" value="1"/>
    </label>
    <button id="resetPoseBtn">é‚„åŸç¶å®šå§¿å‹¢</button>
  </div>
</div>

<div id="errorToast"></div>

<script type="module">
import * as THREE from 'https://esm.sh/three@0.152.2';
import { OrbitControls } from 'https://esm.sh/three@0.152.2/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from 'https://esm.sh/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';
import { BVHLoader } from 'https://esm.sh/three@0.152.2/examples/jsm/loaders/BVHLoader.js';
import * as SkeletonUtils from 'https://esm.sh/three@0.152.2/examples/jsm/utils/SkeletonUtils.js';

/* æœ¬æ©Ÿå„ªå…ˆçš„ç¤ºç¯„è³‡æº */
const LOCAL_SAMPLE = {
  Walk: ["./motions/walk.bvh"],
  "Run (09_01)": ["./motions/run.bvh"]
};
/* ç·šä¸Šå‚™æ´ï¼ˆå¦‚æœæœ¬æ©Ÿæ²’æœ‰ï¼‰ */
const REMOTE_SAMPLE = {
  Walk: [
    "https://raw.githubusercontent.com/una-dinosauria/cmu-mocap/master/data/007/07_01.bvh",
    "https://raw.githubusercontent.com/una-dinosauria/cmu-mocap/master/data/007/07_08.bvh",
    "https://raw.githubusercontent.com/mrdoob/three.js/r152/examples/models/bvh/pirouette.bvh",
    "https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/models/bvh/pirouette.bvh"
  ],
  "Run (09_01)": [
    "https://raw.githubusercontent.com/una-dinosauria/cmu-mocap/master/data/009/09_01.bvh",
    "https://raw.githubusercontent.com/una-dinosauria/cmu-mocap/master/data/009/09_02.bvh",
    "https://raw.githubusercontent.com/una-dinosauria/cmu-mocap/master/data/009/09_03.bvh",
    "https://raw.githubusercontent.com/una-dinosauria/cmu-mocap/master/data/009/09_05.bvh",
    "https://raw.githubusercontent.com/mrdoob/three.js/r152/examples/models/bvh/pirouette.bvh"
  ]
};
const SOLDIER_URLS = [
  "https://raw.githubusercontent.com/mrdoob/three.js/r152/examples/models/gltf/Soldier.glb",
  "https://rawcdn.githack.com/mrdoob/three.js/r152/examples/models/gltf/Soldier.glb"
];

/* DOM */
const app = document.getElementById("app");
const statusEl = document.getElementById("status");
const debugEl = document.getElementById("debug");
const btnLoadModel = document.getElementById("btnLoadModel");
const btnLoadSoldier = document.getElementById("btnLoadSoldier");
const btnLoadSamples = document.getElementById("btnLoadSamples");
const charInput = document.getElementById("charInput");
const motionInput = document.getElementById("motionInput");
const motionSelect = document.getElementById("motionSelect");
const playBtn = document.getElementById("playBtn");
const pauseBtn = document.getElementById("pauseBtn");
const loopChk = document.getElementById("loopChk");
const speed = document.getElementById("speed");
const togglePanelBtn = document.getElementById("togglePanel");
const resetPoseBtn = document.getElementById("resetPoseBtn");
const errorToast = document.getElementById("errorToast");

/* ç‹€æ…‹ */
let renderer, scene, camera, controls, clock = new THREE.Clock();
let model, targetSkeleton, targetMesh;
let mixerBones, mixerNodes;
const actions = new Map();
let current = null;
let bindPose = null;

/* åˆå§‹åŒ– */
init().catch(showFatal);

async function init(){
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(Math.min(devicePixelRatio,2));
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  app.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0f1115);

  camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, .1, 100);
  camera.position.set(0,1.6,3);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.target.set(0,1,0); controls.update();

  const hemi = new THREE.HemisphereLight(0xffffff, 0x202035, .9); scene.add(hemi);
  const dir  = new THREE.DirectionalLight(0xffffff, 1.2); dir.position.set(3,5,2); dir.castShadow = true; dir.shadow.mapSize.set(2048,2048); scene.add(dir);

  const floor = new THREE.Mesh(new THREE.PlaneGeometry(30,30), new THREE.MeshStandardMaterial({color:0x171a24, roughness:1}));
  floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);

  addEventListener("resize", ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

  // é¢æ¿æ”¶åˆ
  let panelOpen = matchMedia('(min-width: 641px)').matches;
  const setPanel=(open)=>{ panelOpen=open; document.getElementById('ui').style.display=open?'flex':'none'; togglePanelBtn.textContent=open?'Ã—':'â˜°'; };
  setPanel(panelOpen);
  togglePanelBtn.addEventListener('click', ()=> setPanel(!panelOpen));

  // äº‹ä»¶
  btnLoadModel.addEventListener("click", ()=>loadCharacterLocal("./character.glb"));
  btnLoadSoldier.addEventListener("click", ()=>loadCharacterFromCandidates(SOLDIER_URLS, "Soldier"));
  btnLoadSamples.addEventListener("click", loadSampleBVHs);

  charInput.addEventListener("change", e=>{ const f=e.target.files?.[0]; if(f) loadCharacterFromFile(f); });
  motionInput.addEventListener("change", e=>{ const files=[...(e.target.files||[])]; if(files.length) loadMultipleMotions(files); });

  motionSelect.addEventListener("change", ()=>{ const name=motionSelect.value; switchToAction(name,0.0,true); });
  playBtn.addEventListener("click", ()=>{ if(current){ forcePlay(current); setStatus("æ’­æ”¾"); }});
  pauseBtn.addEventListener("click", ()=>{ if(current){ current.action.paused=true; setStatus("æš«åœ"); }});
  loopChk.addEventListener("change", ()=>{ for(const {action} of actions.values()){ action.setLoop(loopChk.checked?THREE.LoopRepeat:THREE.LoopOnce,Infinity); action.clampWhenFinished=!loopChk.checked; }});
  speed.addEventListener("input", ()=>{ const v=Number(speed.value); mixerBones && (mixerBones.timeScale=v); mixerNodes && (mixerNodes.timeScale=v); });
  resetPoseBtn.addEventListener("click", restoreBindPose);

  setStatus("è«‹å…ˆè¼‰å…¥è§’è‰²ï¼ˆå»ºè­°å…ˆæŒ‰ã€ä¸€éµç”¨ Soldierã€ï¼‰");
  animate();
}

/* è§’è‰²è¼‰å…¥ */
async function loadCharacterLocal(url){
  try{
    const head = await fetch(url,{method:"HEAD"}); if(!head.ok) throw new Error(`æ‰¾ä¸åˆ° ${url}ï¼ˆHTTP ${head.status}ï¼‰`);
    const gltf = await new GLTFLoader().loadAsync(url);
    useLoadedCharacter(gltf.scene, gltf.animations||[]);
    setStatus("é è¨­è§’è‰²è¼‰å…¥æˆåŠŸ");
  }catch(err){
    showError("æ‰¾ä¸åˆ° ./character.glbï¼Œæ”¹ç‚ºè¼‰å…¥ Soldierã€‚");
    await loadCharacterFromCandidates(SOLDIER_URLS, "Soldierï¼ˆfallbackï¼‰");
  }
}
async function loadCharacterFromCandidates(urls,label){
  let lastErr=null;
  for(const url of urls){
    try{
      const gltf = await new GLTFLoader().loadAsync(url);
      useLoadedCharacter(gltf.scene, gltf.animations||[]);
      setStatus(`è¼‰å…¥ ${label} æˆåŠŸ`);
      return;
    }catch(e){ lastErr=e; }
  }
  showError(`è¼‰å…¥ ${label} å¤±æ•—ï¼š`+(lastErr?.message||lastErr));
}
async function loadCharacterFromFile(file){
  try{
    const url = URL.createObjectURL(file);
    const gltf = await new GLTFLoader().loadAsync(url);
    URL.revokeObjectURL(url);
    useLoadedCharacter(gltf.scene, gltf.animations||[]);
    setStatus("ä¸Šå‚³è§’è‰²è¼‰å…¥æˆåŠŸ");
  }catch(err){ showError("ä¸Šå‚³è§’è‰²å¤±æ•—ï¼š"+(err?.message||err)); }
}

function useLoadedCharacter(sceneObj, characterClips=[]){
  if(model){
    scene.remove(model);
    for(const {action} of actions.values()) action.stop();
    actions.clear(); updateMotionSelect(); current=null; targetSkeleton=null; targetMesh=null; bindPose=null;
  }
  model = sceneObj;
  model.traverse(o=>{
    if(o.isSkinnedMesh && o.skeleton){
      const cur = (targetSkeleton && targetSkeleton.bones.length) || 0;
      if(!targetMesh || o.skeleton.bones.length>cur){ targetMesh=o; targetSkeleton=o.skeleton; }
    }
  });
  if(!targetSkeleton){ throw new Error("æ‰¾ä¸åˆ° SkinnedMesh/Skeletonï¼Œè«‹ç¢ºèªè§’è‰²æœ‰ç¶éª¨ã€‚"); }

  model.position.set(0,0,0);
  scene.add(model);
  model.updateMatrixWorld(true);

  captureBindPose();

  mixerBones = new THREE.AnimationMixer(targetMesh);
  mixerNodes = new THREE.AnimationMixer(model);
  const v = Number(speed.value); mixerBones.timeScale=v; mixerNodes.timeScale=v;

  if(characterClips.length){
    characterClips.forEach((clip,i)=>{
      const name = `GLB / ${clip.name || ("Clip"+i)}`;
      const isBones = clip.tracks.some(t=>t.name.startsWith("bones["));
      addAction(clip, name, isBones ? 'bones' : 'nodes');
    });
    updateMotionSelect();
    const first = actions.keys().next().value; if(first){ motionSelect.value=first; switchToAction(first,0.0,true); }
    setStatus(`è§’è‰² OKï¼šå…§å»º ${characterClips.length} æ®µå‹•ç•«ï¼Œå¯å†è¼‰å…¥ BVH`);
  }else{
    setStatus("è§’è‰² OKï¼šå¯è¼‰å…¥ .bvh æˆ– .glbï¼ˆå«å‹•ç•«ï¼‰");
  }
}

/* ç¶å®šå§¿å‹¢å¿«ç…§ */
function captureBindPose(){
  if(!targetSkeleton) return;
  bindPose = targetSkeleton.bones.map(b=>({bone:b, p:b.position.clone(), q:b.quaternion.clone(), s:b.scale.clone()}));
}
function restoreBindPose(){
  if(!bindPose) return;
  for(const t of bindPose){
    t.bone.position.copy(t.p);
    t.bone.quaternion.copy(t.q);
    t.bone.scale.copy(t.s);
    t.bone.updateMatrix(); t.bone.updateMatrixWorld(true);
  }
  setStatus("å·²é‚„åŸç¶å®šå§¿å‹¢");
}

/* åç¨±æ¨™æº–åŒ–èˆ‡æ˜ å°„ï¼ˆæ”¯æ´ Hips/LHipJoint/LeftUpLegâ€¦ â†’ Mixamoï¼‰ */
function normName(n){
  if(!n) return "";
  n = String(n).replace(/^mixamorig:/i, "").replace(/^armature[:_]?/i, "");
  n = n.replace(/^(l_|lf_|lt_|l)(?=[A-Z])/i, "left")
       .replace(/^(r_|rt_|r)(?=[A-Z])/i, "right");
  n = n.toLowerCase().replace(/[^a-z]/g,"");
  const syn = {
    pelvis:"hips", root:"hips", hip:"hips", hips:"hips",
    lowerback:"spine", abdomen:"spine", chest:"spine2", spine0:"spine",
    neck1:"neck", neck2:"neck", headtop:"head",
    clavicle:"shoulder", shldr:"shoulder", shoulder:"shoulder",
    uparm:"upperarm", upperarm:"upperarm", arm:"arm",
    lowarm:"forearm", forearm:"forearm", forearmtwist:"forearm",
    hand:"hand", fingerbase:"hand", handindex1:"hand",
    thigh:"upleg", upleg:"upleg", leg:"leg", shin:"leg", calf:"leg",
    ball:"toebase", toe:"toebase", toebase:"toebase"
  };
  if(n==="lefthipjoint") n="leftupleg";
  if(n==="righthipjoint") n="rightupleg";
  if(n==="lefttoe") n="lefttoebase";
  if(n==="righttoe") n="righttoebase";
  if(syn[n]) n=syn[n];
  return n;
}
function buildNameMap(srcBones, targetSkeleton){
  const srcByNorm = new Map();
  for(const b of srcBones){
    const nb = normName(b.name);
    if(nb && !srcByNorm.has(nb)) srcByNorm.set(nb, b.name);
  }
  const map = {};
  for(const tb of targetSkeleton.bones){
    const tname = tb.name;
    const norm = normName(tname);
    const tryKeys = [ norm, norm.replace(/^spine1$/,"spine").replace(/^spine3$/,"spine2") ];
    let hit=null;
    for(const k of tryKeys){ if(srcByNorm.has(k)){ hit=srcByNorm.get(k); break; } }
    if(hit) map[tname] = hit;
  }
  return map;
}
function findSourceHipName(bones){
  return (bones.find(b=>/^(hips?|pelvis|root)$/i.test(b.name))?.name) ||
         (bones.find(b=>/hip/i.test(b.name))?.name) || bones[0].name || "Hips";
}
function guessHipName(skel){
  const names = skel.bones.map(b=>b.name);
  return ["Hips","mixamorig:Hips","hip","hips","Root","root"].find(n=>names.includes(n)) || names.find(n=>/hip/i.test(n)) || "Hips";
}

/* å¾ GLTF æ‰¾ä¾†æº skeletonï¼ˆå°±ç®—æ²’ skinned mesh ä¹Ÿç›¡é‡çµ„å‡ºä¾†ï¼‰ */
function findSourceSkeletonFromGLTF(root){
  let skel=null;
  root.traverse(o=>{ if(!skel && o.isSkinnedMesh && o.skeleton){ skel = o.skeleton; } });
  if(skel) return skel;
  const bones=[]; root.traverse(o=>{ if(o.isBone) bones.push(o); });
  if(bones.length){
    const roots = bones.filter(b=>!b.parent || !b.parent.isBone);
    const ordered = [...roots, ...bones.filter(b=>!roots.includes(b))];
    return new THREE.Skeleton(ordered);
  }
  return null;
}

/* ç”¨å„ track çš„ times ä¿®æ­£ clip æ™‚é•·ï¼ˆè™•ç† retargetClip å›å‚³ -1 çš„æƒ…æ³ï¼‰ */
function fixClipDuration(clip){
  if(!clip || !clip.tracks?.length) return 0;
  let maxT = 0;
  for(const t of clip.tracks){
    const arr = t.times;
    if(arr && arr.length){ const last = arr[arr.length-1]; if(last>maxT) maxT=last; }
  }
  // three çš„æ…£ä¾‹ï¼šduration=-1 ä»£è¡¨ã€Œä¾ tracks è‡ªå‹•ç®—ã€ï¼›é€™è£¡ç›´æ¥å¯«å›é¿å…è¢«ç•¶æˆ 0
  if(!isFinite(clip.duration) || clip.duration < 0) clip.duration = maxT;
  return maxT;
}

/* è¼‰å…¥ç¤ºç¯„ï¼ˆå…ˆæœ¬æ©Ÿï¼Œå†ç·šä¸Šï¼‰ */
async function loadSampleBVHs(){
  if(!targetSkeleton){ showError("è«‹å…ˆè¼‰å…¥è§’è‰²ï¼ˆå»ºè­° Soldierï¼‰"); return; }
  setStatus("è¼‰å…¥ç¤ºç¯„ BVHâ€¦");
  let totalAdded = 0;

  for(const [name, urls] of Object.entries(LOCAL_SAMPLE)){
    let ok=false;
    for(const url of urls){
      try{
        const res = await new BVHLoader().loadAsync(url);
        const added = await addBVHAsBakedClip(res, name);
        if(added){ ok=true; totalAdded++; break; }
      }catch(e){ /* æœ¬æ©Ÿä¸å­˜åœ¨å°±ç•¥é */ }
    }
  }
  if(totalAdded===0){
    for(const [name, urls] of Object.entries(REMOTE_SAMPLE)){
      let ok=false;
      for(const url of urls){
        try{
          const res = await new BVHLoader().loadAsync(url);
          const added = await addBVHAsBakedClip(res, name);
          if(added){ ok=true; totalAdded++; break; }
        }catch(e){ console.warn(`[BVH] ä¸‹è¼‰å¤±æ•—ï¼š${name} @ ${url}`, e); }
      }
      if(!ok) console.warn(`[BVH] ${name} æ‰€æœ‰å€™é¸çš†æœªæˆåŠŸã€‚`);
    }
  }

  updateMotionSelect();
  const first = actions.keys().next().value;
  if(first){ motionSelect.value=first; switchToAction(first,0.0,true); }

  if(totalAdded===0){
    showError("ç¤ºç¯„å‹•ä½œè¼‰å…¥å¤±æ•—ï¼ˆæœ¬æ©Ÿèˆ‡ç·šä¸Šçš†æœªæˆåŠŸï¼‰ã€‚è«‹åœ¨ repo æ”¾ /motions/walk.bvh èˆ‡ /motions/run.bvhï¼Œæˆ–ç”¨ã€ä¸Šå‚³å‹•ä½œã€ã€‚");
  }else{
    setStatus(`å·²è¼‰å…¥ ${totalAdded} æ”¯ç¤ºç¯„å‹•ä½œ`);
  }
}

/* ä¸Šå‚³å¤šå€‹å‹•ä½œï¼ˆ.bvh/.glbï¼‰ */
async function loadMultipleMotions(files){
  if(!targetSkeleton){ showError("è«‹å…ˆè¼‰å…¥è§’è‰²ï¼ˆå»ºè­° Soldierï¼‰"); return; }
  let addedAny=false;

  for(const f of files){
    const name=f.name; const ext=name.toLowerCase();
    try{
      if(ext.endsWith('.bvh') || ext.endsWith('.bvh.txt')){
        const text = await readFileText(f);
        const res = new BVHLoader().parse(text);
        const ok = await addBVHAsBakedClip(res, name.replace(/\.(bvh(\.txt)?)$/i,''));
        if(ok) addedAny=true;
      }else if(ext.endsWith('.glb') || ext.endsWith('.gltf')){
        const url = URL.createObjectURL(f);
        try{
          const gltf = await new GLTFLoader().loadAsync(url);
          const srcSkel = findSourceSkeletonFromGLTF(gltf.scene);
          if(!srcSkel || !gltf.animations?.length) throw new Error('GLB ç„¡éª¨æ¶æˆ–å‹•ç•«');
          const hip = guessHipName(targetSkeleton);
          gltf.animations.forEach((clip, idx)=>{
            const clean = clip.clone();
            clean.tracks = clean.tracks.filter(t=>!t.name.endsWith(".position"));
            const baked = SkeletonUtils.retargetClip(targetMesh, srcSkel, clean, { hip, useTargetMatrix:true, preserveHipPosition:true });
            fixClipDuration(baked);
            addAction(baked, `${name} / ${clip.name||("Clip"+idx)}`, 'bones');
          });
          addedAny=true;
        }finally{ URL.revokeObjectURL(url); }
      }else{
        showError(`ä¸æ”¯æ´çš„æ ¼å¼ï¼š${name}`);
      }
    }catch(e){
      showError(`è¼‰å…¥å‹•ä½œå¤±æ•—ï¼ˆ${name}ï¼‰ï¼š`+(e?.message||e));
    }
  }

  updateMotionSelect();
  if(addedAny){
    const first = actions.keys().next().value;
    if(first){ motionSelect.value=first; switchToAction(first,0.0,true); }
    setStatus("å·²è¼‰å…¥ä¸Šå‚³å‹•ä½œ");
  }
}
function readFileText(file){
  return new Promise((resolve,reject)=>{
    const fr = new FileReader();
    fr.onerror = ()=>reject(fr.error||new Error("readFileå¤±æ•—"));
    fr.onload = ()=>resolve(String(fr.result||""));
    fr.readAsText(file);
  });
}

/* BVH â†’ Baked Clipï¼ˆå«éª¨åå°ç…§ï¼‰ï¼Œå›å‚³æ˜¯å¦æˆåŠŸ */
async function addBVHAsBakedClip(bvhResult, displayName){
  let bonesArray=null; const r=bvhResult;
  if (r.skeleton?.bones?.length) bonesArray=r.skeleton.bones;
  else if (r.skeletonHelper?.skeleton?.bones?.length) bonesArray=r.skeletonHelper.skeleton.bones;
  else if (Array.isArray(r.bones) && r.bones.length) bonesArray=r.bones;
  else if (r.restPose?.bones?.length) bonesArray=r.restPose.bones;
  if(!bonesArray){ console.warn("[BVH] ç„¡ bonesï¼š", displayName); return false; }

  const srcSkel = r.skeleton || new THREE.Skeleton(bonesArray);
  let clip = (r.clip && typeof r.clip.clone==='function') ? r.clip.clone() : r.clip;
  if(!clip){ console.warn("[BVH] ç„¡ clipï¼š", displayName); return false; }

  // åªä¿ç•™ä¾†æº hip çš„ positionï¼ˆYï¼‰ï¼Œé¿å…é£„ç§»ï¼›è‹¥æœƒæ¸…åˆ° 0 è»Œå°±ä¿ç•™åŸæ¨£
  const srcHip = findSourceHipName(bonesArray);
  let filtered = clip.tracks.filter(t=>!t.name.endsWith(".position") || t.name===(srcHip+".position"));
  if(filtered.length===0) filtered = clip.tracks;
  const hipPos = filtered.find(t=>t.name===(srcHip+".position"));
  if(hipPos){ const a=hipPos.values; for(let i=0;i<a.length;i+=3){ a[i]=0; a[i+2]=0; } }
  clip = new THREE.AnimationClip(clip.name || displayName, clip.duration, filtered);

  // å»ºå°ç…§è¡¨ï¼ˆtarget Mixamo å â†’ ä¾†æº BVH åï¼‰
  const nameMap = buildNameMap(bonesArray, targetSkeleton);
  const hip = guessHipName(targetSkeleton);

  let baked=null;
  const a={ hip, useTargetMatrix:true,  preserveHipPosition:true, names:nameMap };
  const b={ hip, useTargetMatrix:false, preserveHipPosition:true, names:nameMap };
  try{
    baked = SkeletonUtils.retargetClip(targetMesh, srcSkel, clip, a);
    fixClipDuration(baked);
    if(!(baked?.tracks?.length)) { // è‹¥å®Œå…¨æ²’è»Œï¼Œå†è©¦å¦ä¸€ç¨®
      baked = SkeletonUtils.retargetClip(targetMesh, srcSkel, clip, b);
      fixClipDuration(baked);
    }
  }catch(e){
    try{
      baked = SkeletonUtils.retargetClip(targetMesh, srcSkel, clip, b);
      fixClipDuration(baked);
    }catch(e2){
      console.warn("[BVH] retargetClip çš†å¤±æ•—ï¼š", displayName, e2);
      baked=null;
    }
  }
  if(!baked || !baked.tracks?.length){
    console.warn("[BVH] é‡å®šå‘å¾Œç„¡è»Œï¼ˆå¤šåŠæ˜¯éª¨åå°ä¸ä¸Šï¼‰ï¼š", displayName);
    return false;
  }
  addAction(baked, displayName, 'bones');
  console.log(`[OK] åŠ å…¥å‹•ä½œ ${displayName}ï¼Œduration=${(baked.duration||0).toFixed(3)}s`);
  return true;
}

/* å‹•ä½œç®¡ç†èˆ‡æ’­æ”¾ */
function addAction(clip, name, mixerKind){
  const mixer = mixerKind==='nodes' ? mixerNodes : mixerBones;
  const action = mixer.clipAction(clip);
  action.enabled = true;
  action.setLoop(loopChk.checked?THREE.LoopRepeat:THREE.LoopOnce, Infinity);
  action.clampWhenFinished = !loopChk.checked;
  action.reset();
  action.setEffectiveWeight(1);
  action.setEffectiveTimeScale(Number(speed.value)||1);
  action.paused = false;
  actions.set(name, {action, mixer:mixerKind});
  updateMotionSelect();
  if(!current || current.action.paused){ switchToAction(name,0.0,true); }
}
function updateMotionSelect(){
  const cur = motionSelect.value;
  motionSelect.innerHTML = "";
  if(!actions.size){
    const opt = document.createElement("option"); opt.disabled=true; opt.selected=true; opt.textContent="ï¼ˆå°šæœªè¼‰å…¥å‹•ä½œï¼‰";
    motionSelect.appendChild(opt); return;
  }
  for(const name of actions.keys()){
    const opt = document.createElement("option"); opt.value=name; opt.textContent=name; motionSelect.appendChild(opt);
  }
  if(actions.has(cur)) motionSelect.value=cur;
}
function switchToAction(name, fade=0.0, autoplay=false){
  const next = actions.get(name); if(!next){ showError("æ‰¾ä¸åˆ°å‹•ä½œï¼š"+name); return; }
  for(const [n,ent] of actions){ if(n!==name) ent.action.stop(); }
  next.action.reset();
  next.action.setEffectiveWeight(1);
  next.action.setEffectiveTimeScale(Number(speed.value)||1);
  next.action.paused = false;
  if (autoplay) next.action.play();
  current = next;
  setStatus(`æ’­æ”¾ï¼š${name}`);
}
function forcePlay(entry){
  entry.action.setEffectiveWeight(1);
  entry.action.setEffectiveTimeScale(Number(speed.value)||1);
  entry.action.paused = false;
  entry.action.play();
}

/* è¿´åœˆ */
function animate(){
  requestAnimationFrame(animate);
  const dt = Math.max(0.0001, Math.min(clock.getDelta(), 0.05));
  mixerBones?.update(dt);
  mixerNodes?.update(dt);
  if(current?.action){
    debugEl.textContent = `â± ${current.action.time.toFixed(2)} / ${current.action.getClip().duration.toFixed(2)}s`;
  }else{
    debugEl.textContent = "";
  }
  renderer.render(scene, camera);
}

/* UI å°å·¥å…· */
function setStatus(msg){ statusEl.textContent = msg; }
function showError(msg){ console.error(msg); statusEl.textContent="âš ï¸ "+msg; errorToast.textContent="âš ï¸ "+msg; errorToast.style.display="block"; }
function showFatal(err){ console.error(err); errorToast.textContent="ğŸš« åˆå§‹åŒ–å¤±æ•—ï¼š\n"+(err?.message||err); errorToast.style.display="block"; statusEl.textContent="ğŸš« åˆå§‹åŒ–å¤±æ•—"; }

</script>
</body>
</html>
